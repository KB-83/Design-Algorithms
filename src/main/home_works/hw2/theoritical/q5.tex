\problem{}
ابتدا الگوریتم DSF را روی ریشه درخت اجرا کرده
به این صورت که به هر رأس دو مقدار pre و post را نسبت میدهیم
که اگر یک counter داشته باشیم که نشان دهنده زمان است
مقدار pre هر رأس زمانی است که آن رأس ملاقات شده
و مقدار post آن رأس زمانی است که 
می خواهیم آن رأس را ترک کرده و دیگر فرزندی برای پیمایش ندارد.
پس تا اینجا درخت DFS را برای رأس ها تشکیل میدهیم و 
به هر رأس مقدار $[pre , post]$ را نسبت میدهیم.
که همان اردر زمانی DFS را دارد.$ O(n)$.\\
حالا به بررسی query داده شده میپردازیم.\\
فرض کنیم در پرسش داده شده رأس های $v_1,...,v_i$
به ما داده میشود.
برای اینکه نشان دهیم آیا مسیری از ریشه وجود دارد که شامل همه اینها
باشد یا حداقل به فاصله یک از اینها باشد چند ادعا را ثابت میکنم.\\
ادعا۱:\\
اگر در میان $v_j$ ها رأس با بیشترین مقدار pre را در نظر بگیریم
مسیر این رأس به ریشه همان مسیر مورد نظر است.\\
اثبات:\\
رأس با بیشترین مقدار pre رأسی هست که دیر تر از همه رأس ها ملاقات شده
پس اگر بخواهیم مسیر ما شامل این رأس باشد باید از خودش بگذرد
زیرا مسیر رأس های دیگر به ریشه هیج وقت به این رأس نمیرسد چون هر گاه
 به ریشه میرویم یا به عبارت دیگر به سمت بالا میرویم به رأس هایی به مقادیر
 pre کمتر میرسیم چون آنها زودتر ملاقات شدند 
 که به ریشه نزدیک ترند. درنتیجه اگر چنین رأسی وجود داشته باشد
 حتما همان رأس با بیشترین مقدار pre است.\\
 ادعا ۲:\\
 رأس b در زیر درخت رأس a است اگر و تنها اگر $pre(a)<pre(b)$ و $post(a)>post(b)$.\\
 اثبات:\\
 اگر $pre(a)<pre(b)$ باشد یعنی
 رأس b دیر تر ملاقات شده و از طرف دیگر اگر
 $post(a)>post(ذ)$ باشد یعنی ابتدا از b برگشتیم و سپس به a رسیدیم
 پس a جز اجداد b است.
\\
و اما طرف دیگر اگر a جز اجداد b باشد اول a ملاقات میشود
و سپس b و بعد از b برمیگردیم به a و در نهایت از a برمیگردیم پس داریم:$pre(a)<pre(b)$ و $post(a)>post(b)$.
که ادعا ثابت میشود.\\
ادعا ۳:\\
در مسیر مورد نظر ما بالاترین رأس در درخت DFS بین $v_j$ ها رأسی است که کمترین مقدار
pre را دارد.\\
اثبات :\\
به وضوح مانند ادعا۱ ثابت میشود.\\
ادعا۴:\\
برای اینکه ببینیم رأس $v_j$ در این مسیر هست یا آیا فاصله یک با این مسیر
دارد کافیست بررسی کنیم که آیا خودش در این مسیر هست یا پدرش یا خیر.\\
اثبات:\\
به وضوح اگر خودش در این مسیر باشد ادعا ثابت میشود. حال میخواهم نشان دهم اگر
بخواهیم یک فاصله با این مسیر داشته باشد کافیست پدرش در این مسیر باشد.
رأس هایی که در مسیر هستند فقط به پدرشان و فرزندانشان متصل هستند
زیرا درخت DFS یال بازگشتی ندارد و از طرف دیگر چون گراف ورودی درخت است
$\text{edge cross }$ نیز نداریم.
از طرف دیگر چون گراف ورودی درخت است هر رأس فقط یک پدر دارد در غیر این صورت
دور تشکیل میشود.
از طرف دیگر اگر فرزند یک رأسی در یک مسیر به ریشه باشد
آن رأس نیز به علت اینکه هر رأس یک پدر دارد در آن مسیر هست.
پس تنها حالتی که یک رأس از یک مسیر فاصله یک دارد این است که پدرش در 
آن مسیر باشد.\\
ادعا ۵:\\
یک رأس در یک مسیر بین دو رأس a و b هست اگر و تنها اگر
آن رأس در زیر درخت های a باشد و b در زیر درخت های آن رأس باشد.
(با فرض اینکه ارتفاع b بیشتر از ارتفاع a است.)\\
اثبات:\\
از آنجایی که مسیر بین a و b در درخت یکتاست پس به وضوح این ادعا برقرار است.\\\\
حالا با کمک ادعا هایی که ثابت کردم برای پرسش i ام کافیست
دو رأس a و b را با گرفتن min و max روی مقادیر pre رأس ها مشخص کنم.($O(k_i)$)
و در نهایت برای هر رأس بررسی کنم که آن رأس یا پدرش در زیر درخت a باشند$O(1)$
و b جز رأس های زیر درخت آن رأس یا پدرش باشد.$O(1)$.
که تعداد این رأس ها برابر با $k_i$ هست و از طرف دیگر
تعداد کل پرسش ها $m$ تاست و $\sum{k_i} = k$ پس زمان کل الگوریتم برابر است با:\\
$O(n+m+k)$.