% have to be compeleted.
\problem{}
برای حل این سوال آرایه دو بعدی dp[][] را در نظر میگیریم
و به ترتیب طول زیر رشته ها این آرایه را پر میکنیم به چه صورت؟
به این صورت که dp[i][j]
 برابر است با طول بلند ترین زیر آرایه پالیندروم 
 با شروع از کارکتر i ام رشته و پایان در کاراکتر j ام رشته.
حالا dp[i][j+1] را قرار میدهیم :\\
\[
    dp[i][j+1] = max(dp[i,j],dp[i+1][j+1],dp[i+1][j]+\delta_{i,j+1})    
\]
و داریم:\\
\[
    \delta_{i,j}=
    \begin{cases}
        2 \quad  s[i]=s[j]\\
        0 \quad  \text{else}
    \end{cases}
\]
و اگر زیر فضای مساله ها را ماتریس دو بعدی در نظر بگیریم که ستون های آن نشان دهنده i و
سطر های آن نشان دهنده j است
مساله های اولیه عناصر روی قطر هستند
که همگی یک و در ادامه قطر بعدی را نیز باید به عنوان زیر مساله پر کرد که اگر آن دو حرف با هم برابر بودند
مقدار آن عنصر ۲ و در غیر این صورت ۱ است.
و در ادامه عناصر هر قطر از روی عناصر قطر قبل ساخته میشود.
حالا که طول بلند ترین زیر رشته را پیدا کردیم میتوانیم از جدول برگردیم به عقب و خود زیر آرایه
را پیدا کنیم.
به چه صورت؟\\
در هر قدم وقتی ماکسیمم میگریم یکی از آپشن ها به عنوان ماکسیمم انتخاب شده
حالا اگر یک پوینتر قرار دهیم که از خانه ای که آن را پر کرده به خانه ای که به عنوان ماکسیمم انتخاب
شده اشاره کنیم
آنگاه پس از پر کردن جدول
از خانه اخر که شامل کل رشته میشود شروع کرده
($dp[1][size(string)]$)
و پوینتر هارا دنبال میکنیم
در هر مرحله اگر گزینه ای که پوینتر انتخاب کرده بود
اضافه کردن آن خانه به ته رشته و مشابه آن به سر رشته بود
(خانه بالا سمت چپ در جدول مثلا اگر در خانه i و j باشیم و dp[i+1][j-1] انتخاب شده باشد).
ما نیز به سرو و ته رشته ای که داریم تشکیل میدهیم
آن حرف را اضافه میکنیم.
و در آخر رشته خروجی ساخته شده همان زیر آرایه مورد نظر است.
\\
تحلیل زمان اجرا:\\
پر کردن آرایه دوبعدی ما $O(n^2)$ زمان میبرد و همچنین
بازگشت از خانه اخر به عقب و ساختن رشته نیز $O(n)$ است.
پس کل زمان اجرای الگوریتم برابر است با $O(n^2)$.
