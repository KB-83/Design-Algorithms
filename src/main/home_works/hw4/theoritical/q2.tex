\problem{}
%  need to be edited 
ایده اصلی حل این سوال استفاده از DP است.
برای اینکار کافیست ابتدا یک آرایه جدید n عضوی به نام sum 
معرفی کنیم.
سپس روی آرایه داده شده حرکت کرده و هر خانه sum را به صورت مجموع عناصر خانه
اول ارایه اصلی تا آن خانه در آرایه اصلی نگه داری کنیم به این صورت که:\\
\[
    sum[i] = sum[i-1]+A[i];
\]
که A آرایه ورودی است.\\
حالا دو لیست جدید به نام $1/3$ و $2/3$ معرفی میکنیم
ابتدا روی sum پیمایش کرده و شماره خانه هایی که sum آنها برابر با $\frac{1}{3}$ است را
در آرایه $1/3$ میریزیم.
دقت کنید که این اعداد مرتب شده هستند.
سپس همین کار را دوباره از ابتدای آرایه sum انجام داده و خانه هایی که 
sum آنها $\frac{2}{3}$ است را در لیست $2/3$ میریزیم.
حالا دو لیست مرتب شده داریم و دو پوینتر i و j را در ابتدای لیست های $1/3$ و $2/3$
می گذاریم.
و یکی یکی آنها را جلو میبریم به طریقه الگوریتم ۱.


\begin{algorithm}
    \caption{}
    \[ i \gets 0; \]
    \[ j \gets 0; \]
    \[ num \gets 0;\]
      \[ \text{\LR{While end of \quad $2/3$  or  end of  \quad $1/3$  has not been reached }} \] 
        \[ \text{If} \quad 1/3[i] < 2/3[j]\]
             \[num \gets num + \text{size}(2/3) - j;\]
             \[ i \gets i + 1;\]
        \[\text{Else}\]
             \[j \gets j + 1;\]
        \[\text{While End}\]
\end{algorithm}

که در نهایت num تعداد i و j ها با شرایط خواسته شده سوال را میدهد.
\\

اثبات درستی:\\
\\
اگر مقدار $2/3[j]$ بیشتر از $1/3[i]$
باشد آنگاه 
این یعنی در آرایه اصلی خانه $1/3[i]$ عقب تر از $2/3[j]$ است و همچنین  شرایط جمع های خواسته شده
سوال را نیز دارد
.و چون آرایه مرتب است تمام خانه های بعدی نیز بزرگ ترند و شرایط خواسته شده را دارند
و الگوریتم تعداد این خانه هارا به sum اضافه کرده و سراغ i بعدی میرود.\\
حالا اگر چنین نباشد الگوریتم پوینتر j را جلو میبرد تا جایی که این اتفاق برای آن i بیفتد و 
همچنین چون آرایه $1/3$ نیز مرتب شده است میدانیم برای i های جلوتر نیز
شرایط برقرار نیست پس زیاد کردن j مطمعن است.
\\\\
تحلیل زمانی:\\\\
برای محاسبه آرایه های $1/3$ و $2/3$
هزینه $O(n)$ را اعمال کردیم همچنین الگوریتم ۱ در هر مرحله i یا j را یک واحد زیاد میکند
که این یعنی ماکسیمم $2n$ بار اجرا میشود و در هر بار عملیات $O(1)$ انجام میدهد
پس زمان اجرای الگوریتم برابر است با $O(n)$.

